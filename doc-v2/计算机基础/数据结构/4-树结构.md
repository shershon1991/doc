---
title: "树结构"
date: 2022-05-05
categories: [计算机基础, 数据结构与算法]
tags: [数据结构]
cover: false
---

### 树结构

#### 树的存储结构

将具有“一对多”关系的集合中的数据元素按照树的形式进行存储，称这种存储结构为“树型”存储结构。

**树的结点**

结点：使用树结构存储的每一个数据元素都被称为“结点”

父结点（双亲结点）、子结点和兄弟结点

根结点：每一个非空树都有且只有一个被称为根的结点

叶子结点：若结点没有任何子结点，那么此结点称为叶子结点

**子树和空树**

子树（注意：单个结点也是一棵树）

空树：如果集合本身为空，那么构成的树就被称为空树。空树中没有结点。

注意：在树结构中，对于具有同一个根结点的各个子树，相互之间不能有交集。

**结点的度和层次**

结点的度：对于一个结点，拥有的子树数（结点有多少分支）称为结点的度。

注意：一棵树的度是树内各结点的度的最大值。

结点的层次：从一棵树的树根开始，树根所在层为第一层，根的孩子结点所在的层为第二层， 依次类推。

注意：一棵树的深度是树中结点所在的最大的层次。

注意：若两个结点的父结点虽不相同，但是它们的父结点处在同一层次上，那么这两个结点互为堂兄弟。

**有序树和无序树**

如果树中结点的子树从左到右看，谁在左边，谁在右边，是有规定的，这棵树称为有序树；反之称为无序树。

注意：在有序树中，一个结点最左边的子树称为“第一个孩子”，最右边的称为“最后一个孩子”。

**森林**

由 m（m>=0）个互不相交的树组成的集合被称为森林。

**树的表示方式**

1. 以树型的方式表示

2. 以嵌套的集合的形式表示

3. 使用凹入表示法

4. 使用广义表（最常用）

#### 什么是二叉树

简单地理解，满足以下两个条件的树就是二叉树：

1. 本身是有序树；

2. 树中包含的各个结点的度不能超过 2，即只能是 0、1 或者 2；

**二叉树的性质**

二叉树具有以下几个性质：

1. 二叉树中，第 i 层最多有 2^(i-1) 个结点。

2. 如果二叉树的深度为 K，那么此二叉树最多有 2^K-1 个结点。

3. 二叉树中，终端结点数（叶子结点数）为 n0，度为 2 的结点数为 n2，则 n0=n2+1。

二叉树还可以继续分类，衍生出满二叉树和完全二叉树。

**满二叉树**

如果二叉树中除了叶子结点，每个结点的度都为 2，则此二叉树称为满二叉树。

满二叉树除了满足普通二叉树的性质，还具有以下性质：

1. 满二叉树中第 i 层的结点数为 2^(i-1) 个。

2. 深度为 k 的满二叉树必有 2^k-1 个结点 ，叶子数为 2^(k-1)个。

3. 满二叉树中不存在度为 1 的结点，每一个分支点中都两棵深度相同的子树，且叶子结点都在最底层。

4. 具有 n 个结点的满二叉树的深度为 log2(n+1)。

**完全二叉树**

如果二叉树中除去最后一层结点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树。

如果将含有的结点按照层次从左到右依次标号，对于任意一个结点 i，完全二叉树还有以下几个结论成立：

1. 当 i>1 时，父亲结点为结点 i/2↓ 。（i=1 时，表示的是根结点，无父亲结点）

2. 如果 2*i>n（总结点的个数），则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2*i。

3. 如果 2*i+1>n，则结点 i 肯定没有右孩子；否则右孩子是结点 2*i+1。

#### 二叉树的顺序存储结构

二叉树的顺序存储，指的是使用 顺序表（ 数组）存储二叉树。需要注意的是，顺序存储只适用于完全二叉树。换句话说，只有完全二叉树才可以使用顺序表存储。因此，如果我们想顺序存储普通二叉树，需要提前将普通二叉树转化为完全二叉树。

普通二叉树转完全二叉树的方法很简单，只需给二叉树额外添加一些结点，将其"拼凑"成完全二叉树即可。

完全二叉树的顺序存储，仅需从根结点开始，按照层次依次将树中结点存储到数组即可。

**具体实现**

省略。

#### 二叉树的链式存储结构

采用链式存储二叉树时，其结点结构由 3 部分构成：

1. 指向左孩子结点的指针（Lchild）；

2. 结点存储的数据（data）；

3. 指向右孩子结点的指针（Rchild）；

**具体实现**

见代码。

4.5 二叉树的遍历算法（4 种）

**遍历二叉树的算法**

1. 层次遍历

通过对树中各层的结点从左到右依次遍历，即可实现对整棵二叉树的遍历，此种 方式称为层次遍历。

![img](https://raw.githubusercontent.com/shershon1991/picImgBed/master/dataStructAndAlgorithm/wpsOtcnLs.jpg)

2. 普通遍历

其实，还有一种更普通的遍历二叉树的思想，即按照 "从上到下，从左到右" 的顺 序遍历整棵二叉树。

![img](https://raw.githubusercontent.com/shershon1991/picImgBed/master/dataStructAndAlgorithm/wpsyx7xbn.jpg)

**二叉树遍历算法再剖析**

层次遍历，整个遍历过程只经过各个结点一次，因此在层次遍历过程，每经过一个结点，都必须立刻访问该结点，否则错失良机，后续无法再对其访问。

而普通遍历方式则不同，整个遍历二叉树的过程中，每个结点都被经过了 3 次（虽然叶子结点看似只经过了 2 次，但实际上可以看做是 3
次）。因此，在编程实现时，我们可以设定真正访问各个结点的时机，换句话说，我们既可以在第一次经过各结点时就执行访问程序，也可以在第二次经过各结点时访问，甚至可以在最后一次经过各结点时访问。这也就引出了以下 3 种遍历二叉树的算法：

1. 先序遍历：每遇到一个结点，先访问，然后再遍历其左右子树

2. 中序遍历：第一次经过时不访问，等遍历完左子树之后再访问，然后遍历右子树

3. 后序遍历：第一次和第二次经过时都不访问，等遍历完该结点的左右子树之后，最后访问该结点

#### 二叉树的先序遍历（递归和非递归）

见代码。

#### 二叉树的中序遍历（递归和非递归）

见代码。

#### 二叉树的后序遍历（递归和非递归）

见代码。

#### 二叉树的层次遍历

见代码。

#### 树的双亲表示法

存储具有普通树结构数据的方法有3种：

1. 双亲表示法

2. 孩子表示法

3. 孩子兄弟表示法

双亲表示法采用 顺序表 （也就是数组）存储普通树，其实现的核心思想是：顺序存储各个结点的同时，给各结点附加一个记录其父结点位置的变量。

注意：根结点没有父结点（父结点又称为双亲结点），因此根结点记录父结点位置的变量通常置为 -1。

![img](https://raw.githubusercontent.com/shershon1991/picImgBed/master/dataStructAndAlgorithm/wpsk8VuVk.jpg)

![img](https://raw.githubusercontent.com/shershon1991/picImgBed/master/dataStructAndAlgorithm/wpsdZ5cP8.jpg)

**具体实现**

见代码。

#### 树的孩子表示法

孩子表示法存储普通树采用的是 "顺序表 + 链表" 的组合结构，其存储过程是：从树的根结点开始，使用顺序表依次存储树中各个结点，需要注意的是，与双亲表示法不同，孩子表示法会给各个结点配备一个链表，用于存储各结点的孩子结点位于顺序表中的位置。

如果结点没有孩子结点（即该结点为叶子结点），则该结点的链表为空链表。

![img](https://raw.githubusercontent.com/shershon1991/picImgBed/master/dataStructAndAlgorithm/wpsx0WQEL.jpg)

**具体实现**

见代码。

#### 树的孩子兄弟表示法

孩子兄弟表示法，采用的是链式存储结构，其存储树的实现思想是：从树的根结点开始，依次用链表存储各个结点的孩子结点和兄弟结点。

因此，该链表中的结点应包含以下 3 部分内容（如图 2 所示）：

1. 结点的值；

2. 指向孩子结点的指针；

3. 指向兄弟结点的指针；

![img](https://raw.githubusercontent.com/shershon1991/picImgBed/master/dataStructAndAlgorithm/wpsP4hLpf.jpg)

![img](https://raw.githubusercontent.com/shershon1991/picImgBed/master/dataStructAndAlgorithm/wpsD9g6dr.jpg)

通过孩子兄弟表示法，任意一棵普通树都可以相应转化为一棵二叉树，换句话说，任意一棵普通树都有唯一的一棵二叉树与其对应。

因此，孩子兄弟表示法可以作为将普通树转化为二叉树的最有效方法，通常又被称为"二叉树表示法"或"二叉链表表示法"。

**具体实现**

省略。

#### 森林转换为二叉树

任意一棵普通树都可以转化为二叉树，而森林是由多棵普通树构成的，因此自然也可以转化为二叉树，其转化方法是：

1. 首先将森林中所有的普通树各自转化为二叉树；

2. 将森林中第一棵树的树根作为整个森林的树根，其他树的根结点看作是第一棵树根 结点的兄弟结点，采用孩子兄弟表示法将所有树进行连接；

注意：由二叉树转化为森林的过程也就是森林转化二叉树的逆过程。

#### 赫夫曼树（哈夫曼树、最优树）

**赫夫曼树相关的几个名词**

路径：在一棵树中，一个结点到另一个结点之间的通路，称为路径。

路径长度：在一条路径中，每经过一个结点，路径长度都要加 1。

结点的权：给每一个结点赋予一个新的数值，被称为这个结点的权。

结点的带权路径长度：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。

树的带权路径长度为树中所有叶子结点的带权路径长度之和。通常记作 “WPL” 。

**什么是赫夫曼树**

当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。

注意：在构建赫夫曼树时，要使树的带权路径长度最小，只需要遵循一个原则，那就是：权重越大的结点离树根越近。

**构建赫夫曼树**

对于给定的有各自权值的 n 个结点，构建哈夫曼树有一个行之有效的办法：

1. 在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；

2. 在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推；

3. 重复 1 和 2，直到所以的结点构建成了一棵二叉树为止，这棵树就是赫夫曼树。

**赫夫曼树的结点结构**

构建赫夫曼树时，首先需要确定树中结点的构成。由于赫夫曼树的构建是从叶子结点开始，不断地构建新的父结点，直至树根，所以结点中应包含指向父结点的指针。但是在使用赫夫曼树时是从树根开始，根据需求遍历树中的结点，因此每个结点需要有指向其左孩子和右孩子的指针。

**赫夫曼树中的查找算法**

构建赫夫曼树时，需要每次根据各个结点的权重值，筛选出其中值最小的两个结点，然后构建二叉树。
查找权重值最小的两个结点的思想是：从树组起始位置开始，首先找到两个无父结点的结点（说明还未使用其构建成树），然后和后续无父结点的结点依次做比较，有两种情况需要考虑：

l 如果比两个结点中较小的那个还小，就保留这个结点，删除原来较大的结点；

l 如果介于两个结点权重值之间，替换原来较大的结点；

**构建赫夫曼树的代码实现**

见代码。

**赫夫曼编码**

赫夫曼编码就是在赫夫曼树的基础上构建的，这种编码方式最大的优点就是用最少的字符包含最多的信息内容。

#### 回溯算法

回溯法，又被称为“试探法”。解决问题时，每进行一步，都是抱着试试看的态度，如果发现当前选择并不是最好的，或者这么走下去肯定达不到目标，立刻做回退操作重新选择。这种走不通就回退再走的方法就是回溯法。

**回溯 VS 递归**

回溯法从问题本身出发，寻找可能实现的所有情况。和穷举法的思想相近，不同在于穷举法是将所有的情况都列举出来以后再一一筛选，而回溯法在列举过程如果发现当前情况根本不可能存在，就停止后续的所有工作，返回上一步进行新的尝试。
递归是从问题的结果出发，例如求 n！，要想知道 n！的结果，就需要知道 n*(n-1)! 的结果，而要想知道 (n-1)! 结果，就需要提前知道 (n-1)*(n-2)!。这样不断地向自己提问，不断地调用自己的思想就是递归。
回溯和递归唯一的联系就是，回溯法可以用递归思想实现。

**回溯法和树的遍历**

回溯法的求解过程实质上是先序遍历“状态树”的过程。

在某些情况下，回溯法解决问题的过程中创建的状态树并不都是满二叉树，因为在试探的过程中，有时会发现此种情况下，再往下进行没有意义，所以会放弃这条死路，回溯到上一步。在树中的体现，就是在树的最后一层不是满的，即不是满二叉树，需要自己判断哪些叶子结点代表的是正确的结果。

**回溯法解决八皇后问题**

八皇后问题是以国际象棋为背景的问题：有八个皇后（可以当成八个棋子），如何在 8*8 的棋盘中放置八个皇后，使得任意两个皇后都不在同一条横线、纵线或者斜线上。

八皇后问题是使用回溯法解决的典型案例。算法的解决思路是：

1. 从棋盘的第一行开始，从第一个位置开始，依次判断当前位置是否能够放置皇后，判断的依据为：同该行之前的所有行中皇后的所在位置进行比较，如果在同一列，或者在同一条斜线上（斜线有两条，为正方形的两个对角线），都不符合要求，继续检验后序的位置。

2. 如果该行所有位置都不符合要求，则回溯到前一行，改变皇后的位置，继续试探。

3. 如果试探到最后一行，所有皇后摆放完毕，则直接打印出 8*8 的棋盘。最后一定要记得将棋盘恢复原样，避免影响下一次摆放。

#### n个结点的二叉树种类

对于任意一棵普通树，通过 孩子兄弟表示法 的转化，都可以找到唯一的一棵二叉树与之对应。所以本节研究的题目也可以转化成：n 个结点可以构建多少种形态不同的二叉树。

每一棵普通树对应的都是一棵没有右子树的二叉树，所以对于 n 个结点的树来说，树的形态改变是因为除了根结点之外的其它结点改变形态得到的，所以，n 个结点构建的形态不同的树与之对应的是 n-1 个结点构建的形态不同的二叉树。 如果 tn 表示
n 个结点构建的形态不同的树的数量，bn 表示 n 个结点构建的形态不同的二叉树的数量，则两者之间有这样的关系：tn=bn-1。

**方法一**

最直接的一种方法就是推理。

**方法二**

从遍历二叉树的角度进行分析，对于任意一棵二叉树来说，它的前序序列和中序序列以及后序序列都是唯一的。其实是这句话还可以倒过来说，只要确定了一棵二叉树的三种遍历序列中的两种，那么这棵二叉树也可以唯一确定。

#### 红黑树

红黑树的定义：

l 每个节点都是红色或者黑色

l 根节点是黑色

l 每一个叶子节点都是黑色

l 若一个节点为红色，它的孩子节点就为黑色

l 从任意一个节点到叶子节点，经过的黑色节点是一样的

红黑树要对一个插入操作进行维护，会进行左旋转、右旋转、颜色翻转，如下图：

![img](https://raw.githubusercontent.com/shershon1991/picImgBed/master/dataStructAndAlgorithm/wpswH5Wto.jpg)

因为我们默认新添加一个节点的时候是红色，我们要使节点满足上述5点红黑树的定义，首先，我们需要像AVL那样将图2的树形态旋转为3形态，再想AVL一样右旋转为图4状态，这时虽然达到平衡但是反转颜色（令双亲结点为红，孩子节点为黑），最后将根节点变为黑色即可。

**左旋转**

// node x

// / \ 左旋转 / \

// T1 x --------->  node T3

// / \ / \

// T2 T3 T1 T2

private Node leftRotate(Node node){

​ Node x = node.right;

​ // 左旋转

​ node.right = x.left;

​ x.left = node;

​ x.color = node.color;

​ node.color = RED;

​ return x;

}

**右旋转**

// node x

// / \ 右旋转 / \

// x T2 ------->  y node

// / \ / \

// y T1 T1 T2

private Node rightRotate(Node node){

​ Node x = node.left;

​ // 右旋转

​ node.left = x.right;

​ x.right = node;

​ x.color = node.color;

​ node.color = RED;

​ return x;

}

**颜色翻转**

// 颜色翻转

private void flipColors(Node node){

​ node.color = RED;

​ node.left.color = BLACK;

​ node.right.color = BLACK;

}

**为什么有了AVL还需要有红黑树？**

红黑树并没有像AVL追求平衡，他不像AVL要求每个节点的平衡因子绝对值必须小于等于1。这样相对于AVL来说红黑树的旋转操作会更少，例如删除，插入节点操作，AVL是要从删除，增加节点到根节点的所有节点进行平衡旋转(O(logn))
，而红黑树最多只需要3次就可以实现平衡O(1)(虽然通过上文实现的红黑树并不能做到，但有实现是可以的)，所以红黑树更适合增删多的场景。

所以，在增删多的场景选择红黑树，查找多的场景选择AVL（平衡二叉树）。